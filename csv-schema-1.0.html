
<!DOCTYPE html>
<html>
  <head>
    <title>CSV Schema 1.0</title>
    <meta charset='utf-8'/>
    <script src='http://www.w3.org/Tools/respec/respec-w3c-common' class='remove'></script>
    <script class='remove'>
      var respecConfig = {
          // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
          specStatus:           "unofficial",
          additionalCopyrightHolders: "Mozilla Public Licence version 2.0",
          
          // the specification's short name, as in http://www.w3.org/TR/short-name/
          shortName:            "csvs",

          // if your specification has a subtitle that goes below the main
          // formal title, define it here
          subtitle   :  "A Language for Defining and Validating CSV Data",

          // if you wish the publication date to be other than today, set this
          publishDate:  "2013-11-01",

          // if the specification's copyright date is a range of years, specify
          // the start date here:
          // copyrightStart: "2005"

          // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
          // and its maturity status
          // previousPublishDate:  "1977-03-15",
          // previousMaturity:  "WD",

          // if there a publicly available Editor's Draft, this is the link
          // edDraftURI:           "http://dev.w3.org/2009/dap/ReSpec.js/documentation.html",
          edDraftURI:           "http://digitalpreservation.github.com/csv-validator/csv-schema-1.0.html",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",

          // editors, add as many as you like
          // only "name" is required
          editors:  [
              { name: "Adam Retter", url: "http://adamretter.org.uk/",
                company: "Adam Retter Consulting", companyURL: "http://adamretter.org.uk/" },
              { name: "David Underdown", 
                company: "The National Archives", companyURL: "http://www.nationalarchives.gov.uk" },
          ],

          // authors, add as many as you like. 
          // This is optional, uncomment if you have authors as well as editors.
          // only "name" is required. Same format as editors.

          //authors:  [
          //    { name: "Your Name", url: "http://example.org/",
          //      company: "Your Company", companyURL: "http://example.com/" },
          //],
          
          // name of the WG
          wg:           "The National Archives - Digital Preservation",
          
          // URI of the public WG page
          wgURI:        "http://www.nationalarchives.gov.uk/information-management/projects-and-work/digital-preservation.htm",
          
          // name (without the @w3c.org) of the public mailing to which comments are due
          wgPublicList: "csvs",
          
          // URI of the patent status for this WG, for Rec-track documents
          // !!!! IMPORTANT !!!!
          // This is important for Rec-track documents, do not copy a patent URI from a random
          // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
          // Team Contact.
          wgPatentURI:  "",
          
          // If specified, defines an array of alternate formats in which document is available (e.g., XML, Postscript). The format of the array is:
          // alternateFormats:
          
          doRDFa: "1.1",
      };
    </script>
    <style>
      <!--
        div.exampleInner {
          background-color: #D5DEE3;
          border-top-width: 4px;
          border-top-style: double;
          border-top-color: lightGrey;
          border-bottom-width: 4px;
          border-bottom-style: double;
          border-bottom-color: lightGrey;
          padding: 4px;
          margin: 0em;
        }
        
        code.function {
          font-weight: bold;
        }
        
        code.return-type {
          font-style: italic;
        }
        
        code.type {
          font-style: italic;
        }
        
        span.explain {
          font-family: sans-serif;
          font-style: italic;
        }
        
        .principle, .point {
            font: small-caps 100% sans-serif;
        }
		ol.nested
		{
			counter-reset: item
		}
		li.nested
		{
			display: block
		}
		li.nested:before
		{
			content: counters(item, ".") ". ";
			counter-increment: item
		}
		-->
    </style>
  </head>
  <body>
    <section id="sotd">
      This document represents the specification of the CSV Schema 1.0 language
      as defined by <a href="http://www.nationalarchives.gov.uk">The National Archives</a>.
      It is unclear yet whether this document will be submitted to a formal standards body
      such as the <a href="http://w3.org">W3C</a>.
    </section> 
    <section id='abstract'>
      <acronym title="Comma Separated Value">CSV</acronym> data comes in many shapes and sizes. Apart from [[RFC4180]] which is fairly recent and frequently ignored
      there is a lack of formal definition as to CSV data formats and in many ways this is one of its strengths.
      However, extracting structured information from CSV data for further processing or storage
      can prove difficult if the CSV data is not well understood or perhaps not even uniform. CSV Schema
      defines a textual language which can be used to define the data structure, types and rules for
      particular CSV data.
    </section>
    
    <section id="introduction" class='informative'>
        <h1>Introduction</h1>
        <p>
            The intention of this document is twofold:
            <ol>
                <li>To be informative to users who are writing CSV Schemas, and provide a reference to the available syntax and functions.</li>
                <li>To provide enough detail such that anyone with sufficient technical expertise should be able to implement a CSV Schema parser and/or CSV validator following the rules defined in a CSV Schema.</li>
            </ol>
        </p>
        <section id="background">
            <h2>Background</h2>
            <p>
                The National Archives Digital Repository Infrastructure system archives digitised and born-digital materials provided by <acronym title="Other Governmental Department">OGD</acronym>s
                and occasionally <acronym title="Non Governmental Organisation">NGO</acronym>s. For the purposes of Digital Preservation the system processes and archives large amounts of metadata, much
                of this metadata is created by the supplying organisation or by transcription. The metadata is further processed, and ultimately stored both online in an
                <acronym title="Resource Description Format">RDF</acronym> Triplestore and a majority subset archived in a non-RDF <acronym title="eXtensible Markup Language">XML</acronym> format.
                However it was recognised that the creation of XML or RDF metadata by the supplier
                was most likely unrealistic for either technical or financial reasons. As such, CSV was recognised as a simple data format that is human readable (to a degree), that almost anyone could create
                simply; effectively CSV is the lowest common denominator in structured data formats.
            </p>
            <p>
                The National Archives have strict rules about various CSV file formats that they expect, and how the data in those file formats should be set out. To ensure the quality of their archival metadata
                it was recognised that CSV files would have to be validated, as such a general schema language for CSV was developed alongside a validation tool.
            </p>
        </section>
        <section id="principles">
            <h2>Guiding Principles</h2>
            <p>The design of the CSV Schema language has been influenced by a few guiding principles, understanding these will help you to understand how and why it is structured the way that it is.</p>
            <ul>
                <li>
                    <div class="principle">Simplicity</div>
                    <p>The language should be expressible in plain text and should be simple enough that archival domain experts could easily write it without having to know a programming language or data/document modelling language such as XML or RDF.</p>
                    <p><strong>Note</strong>, the CSV Schema Language is NOT itself expressed in CSV, it is expressed in a simple text format.</p>
                </li>
                <li>
                    <div class="principle">Context is King!</div>
                    <p>A schema rule is written for each column of the CSV file. Each set of column rules are asserted against each row of the CSV file. Each rule in the CSV Schema operates on the current context (e.g. defined Column and parsed Row), unless otherwise specified. This makes the rules short and concise.</p>
                </li>
                <li>
                    <div class="principle">Stream Processing</div>
                    <p>Metadata files may be very large as such the CSV Schema Language was designed with concern for implementation of a validation tool which could read and process CSV data as a stream. Few operations require mnenomization of data from the CSV file, and where they do this is limited and should be optimisable to keep memory use to a minimum.</p>
                </li>
                <li>
                    <div class="principle">Sane Defaults</div>
                    <p>We try to do the right thing by default. CSV files and their brethren (Tab Separated Values etc.) can come in many shapes and sizes, by default we assume the CSV data format will comply with [[RFC4180]], of course we allow you to customize this behaviour in the CSV Schema.</p>
                </li>
                <li>
                    <div class="principle">Not a Programming Language.</div>
                    <p>This is worth stressing as it was something we had to keep sight of ourselves during development; CSV Schema is a simple data definition and validation language for CSV!</p>
                </li>
            </ul>
        </section>
    </section>
    <section id="basics" class="informative">
        <h1>Basics</h1>
        <p>
            A CSV Schema is really a rules based language which defines how data in each cell should be formatted.
            Rules are expressed per-column of the CSV data. Rules are evaluated for each row in the CSV data.
            A column rule may express constraints based on the content of other columns in the same row, however at present there is no scope for looking forward or backward through rows directly.
			However, it possible to check that a cell entry is unique within that column in the CSV file (or that the value of a combination of cells is unique)
        </p>
        <p>
            A CSV Schema is made up of two main parts:
			<ol class="nested">
				<li class="nested"><span class="point"><a>Prolog</a></span>
				<p>In turn this comprises (at most) two sections (the second being OPTIONAL):</p>
				<ol class="nested">
					<li class="nested">
						<span class="point"><a>Version Declaration</a></span>
						<p>The CSV Schema MUST explicitly state (as its first non-comment line) the version of the CSV Schema language that it uses. This is to allow for future evolution of the CSV Schema language to be easily handled by CSV Schema processors.</p>
					</li>
					<li class="nested">
						<span class="point"><a>Global Directives</a></span>
						<p>Global Directives apply to all processing of the CSV data. Global Directives for example allow you to define the separator sequence between columns in the CSV data. Global Directives appear before Column Rules and are prefixed with an <code>@</code> character.</p>
						<p>The use of Global Directives is OPTIONAL, default values are used if they are not specified.</p>
					</li>
				</ol>
				</li>
				<li class="nested">
					<span class="point"><a>Body</a></span>
					<p>The Body of the CSV Schema MUST declare, in order, a <a>Column Rule</a> for each Column in the CSV data. If validation of a Column is not desirable, then an empty rule is used.</p>
				</li>
			</ol>
        </p>
        <p>
            Let's now illustrate a simple CSV Schema that is concerned with CSV data about names, ages and gender:
            <pre class="example" title="Simple CSV Schema">
version 1.0

@totalColumns 3

name: notEmpty
age: range(0, 120)
gender: is("m") or is("f") or is("t") or is("n") 
            </pre>
            This CSV Schema basically defines that the CSV data must have 3 columns: the first
            column, <em>name</em>, must have some sort of value; the second column, <em>age</em>,
            must be a number between 0 and 120 inclusive; and the third column, <em>gender</em>,
            must be one of the characters m, f, t or n. An example of CSV data that would match the
            rule definitions in the CSV schema could be as follows:
            <pre class="example" title="Valid CSV Data">
name,age,gender
james,21,m
lauren,19,f
simon,57,m
            </pre>
            An example of CSV data would fail the rule definitions in the CSV schema could be
            as follows:
            <pre class="example" title="Invalid CSV Data">
name,age,gender
james,4 years,m
lauren,19,f
simon,57,male
            </pre>
            The Invalid CSV Data example above fails when validated against the CSV Schema because: 1) at row 2 column 2, "4 years" is not a number between 1 and 120 inclusive, and 2) at row 4 column 3, "male" is not one of the characters m, f, t, or n.
        </p>
    </section>
    <section>
		<h1>Schema structure</h1>
		<p>
		The CSV schema language is formally a <a href="http://en.wikipedia.org/wiki/Context-free_grammar">context-free grammar</a>
		expressed in <a href="http://en.wikipedia.org/wiki/EBNF"><dfn title="EBNF">Extended Backhaus-Naur Form</dfn></a>  (EBNF - see also [[RFC5234]])
		</p>
		<p>
		The following subsections examine the structure of a CSV Schema in more detail. 
		Each subsection comprises definitions of terms, cross-references to other definitions, 
		the relevant portion of the <a>EBNF</a> (links on the lefthandside go to the appendix containing the full EBNF, those on the right to a fuller explanation of those term(s)), 
		and examples of correct usage.
		</p>
		<p>
		A CSV schema MUST comprise both <a>Prolog</a> and <a>Body</a>.
		</p>
		<table class="ebnf-table">
			<tr>
				<td class="ebnf-num">[1]</td>
				<td class="ebnf-left"><a title="ebnf-schema"><dfn>Schema</dfn></a></td>
				<td>::=</td>
				<td class="ebnf-right"><a>Prolog</a> <a>Body</a></td>
			</tr>
		</table>
		<section>
			<h2>Prolog</h2>
			<p>The <dfn>Prolog</dfn> of a CSV Schema MUST contain the <a>Version Declaration</a> and MAY contain one or more <a>Global Directives</a>.</p>
			<table class="ebnf-table">
				<tr>
					<td class="ebnf-num">[2]</td>
					<td class="ebnf-left"><a title="ebnf-prolog"><dfn title="prolog-def">Prolog</dfn></a></td>
					<td>::=</td>
					<td class="ebnf-right"><a>VersionDecl</a> <a>GlobalDirectives</a></td>
				</tr>
			</table>
			<section>
				<h3>Version Declaration</h3>
				<p>
				The <dfn>Version Declaration</dfn> declares explicitly which version of the CSV Schema language is in use. 
				At present this MUST be fixed to <code>version 1.0</code>. 
				If the version is not valid this is considered a <a>Schema Error</a>. 
				The Version Declaration is MANDATORY.
				</p>
				<table class="ebnf-table">
					<tr>
						<td class="ebnf-num">[3]</td>
						<td class="ebnf-left"><a title="ebnf-version-decl"><dfn>VersionDecl</dfn></a></td>
						<td>::=</td>
						<td class="ebnf-right">"version 1.0"</td>
					</tr>
				</table>
					<section>
					<h4>Example Version Declaration</h4>
					<p>
						<pre class="example" title="Version Declaration Syntax">
	version 1.0
						</pre>
					</p>
				</section>
			</section>
			<section>
				<h3>Global Directives</h3>
				<p>
				The <dfn>Global Directives</dfn> allow you to modify the overall processing of a CSV file or how subsequent <a name="Column Definition">Column Definitions</a> are evaluated. 
				The use of Global Directives within a CSV Schema is OPTIONAL.
				The last two Global Directives described (<a>No Header Directive</a> and <a>Ignore Column Name Case Directive</a>) are mutually exclusive, 
				they MUST NOT both be used in a single schema. 
				There is no inherent reason why the Global Directives should be in the order shown, <a>EBNF</a> does not directly cater for unordered lists.
				You could explicitly list each possible ordering, but that would require 4!=24 orderings to be included in the ENBF.
				All directives (both Global Directives and <a>Column Directives</a>) used in the CSV Schema are indicated by the <dfn>Directive Prefix</dfn>, 
				defined as the character <code>@</code> i.e. the [[UTF-8]] character code <code>0x40</code>.
				</p>
				<p>
				Whitespace is not generally significant, so Global Directives can be entered all on a single line, or each on separate lines 
				(see <a href="#example-global-directives"></a>).
				</p>
				<table class="ebnf-table">
					<tr>
						<td class="ebnf-num">[4]</td>
						<td class="ebnf-left"><a title="ebnf-global-directives"><dfn>GlobalDirectives</dfn></a></td>
						<td>::=</td>
						<td class="ebnf-right"><a>SeparatorDirective</a>? <a>QuotedDirective</a>? <a>TotalColumnsDirective</a>? (<a>NoHeaderDirective</a> | <a>IgnoreColumnNameCaseDirective</a>)?</td>
					</tr>
					<tr>
						<td class="ebnf-num">[5]</td>
						<td class="ebnf-left"><a title="ebnf-directive-prefix"><dfn>DirectivePrefix</dfn></a></td>
						<td>::=</td>
						<td class="ebnf-right">"@"</td>
					</tr>
				</table>
				<section>
					<h4>Separator Directive</h4>
					<p>The <dfn>Separator Directive</dfn> allows you to specify the separator character that is used between columns in the CSV data. 
					As with all <a>Global Directives</a> the Separator Directive is OPTIONAL, if not supplied the default value is assumed.
					By default the separator is a <code>comma</code> i.e. the [[UTF-8]] character code <code>0x2c</code> (as specified in [[RFC4180]]).
					</p>
					<p>
					The Separator Directive takes a MANDATORY parameter in the form of either a <dfn>TAB Expression</dfn> or a <dfn>Separator Character</dfn>.
					</p>
					<p>
					A <a>TAB Expression</a> indicates that the separator comprises one (or more) <code>spaces</code> i.e. the [[UTF-8]] character code <code>0x20</code>. 
					It takes an OPTIONAL parameter of an <dfn>Integer Literal</dfn>: any positive, non-zero, integer value.
					If no value is supplied, the default of four spaces is assumed, but any other positive number can be specified as an integer input to the parameter.
					<!--In fact currently any integer value would be accepted, even 0 or -ve values, this has been raised as an issue-->
					</p>
					<p>
					A <a>Separator Character</a> is a <a>Character Literal</a>: the character which is to be treated as the column separator.
					</p>
					<!-- following two paras probably logically fit lower down, as the ReSpec crossreferences will allow people to go directly to them-->
					<p>
					A <dfn>Character Literal</dfn> is a single <a>Non-breaking Character</a>.
					</p>
					<p>
					<dfn>Non-breaking Character</dfn>: Unicode characters not including those represented in regex by <code>\n</code> or <code>\r</code><!--Unicode equivalents??-->.
					</p>
					<table class="ebnf-table">
						<tr>
							<td class="ebnf-num">[6]</td>
							<td class="ebnf-left"><a title="ebnf-separator-directive"><dfn>SeparatorDirective</dfn></a></td>
							<td>::=</td>
							<td class="ebnf-right"><a>DirectivePrefix</a> "separator" (<a>TABExpr</a> | <a>SeparatorChar</a>)</td>
						</tr>
						<tr>
							<td class="ebnf-num">[7]</td>
							<td class="ebnf-left"><a title="ebnf-tab-expr"><dfn>TABExpr</dfn></a></td>
							<td>::=</td>
							<td class="ebnf-right">"TAB" ("(" <a title="ebnf-integer-literal">IntegerLiteral</a> ")")?</td>
						</tr>
						<tr>
							<td class="ebnf-num">[8]</td>
							<td class="ebnf-left"><a title="ebnf-separator-char"><dfn>SeparatorChar</dfn></a></td>
							<td>::=</td>
							<td class="ebnf-right"><a title="ebnf-character-literal">CharacterLiteral</a></td>
						</tr>
						
					</table>
				</section>
				<section>
					<h4>Quoted Directive</h4>
					<p>The <dfn>Quoted Directive</dfn> allows you to specify whether or not all columns are quoted.</p>
					<table class="ebnf-table">
						<tr>
							<td class="ebnf-num">[9]</td>
							<td class="ebnf-left"><a title="ebnf-quoted-directive"><dfn>QuotedDirective</dfn></a></td>
							<td>::=</td>
							<td class="ebnf-right"><a>DirectivePrefix</a> "quoted"</td>
						</tr>     
					</table>
				</section>
				<section>
					<h4>Total Columns Directive</h4>
					<p>
					The <dfn>Total Columns Directive</dfn> allows you to specify the total number of data columns expected to make up each row of the CSV file.
					The parser will also verify that the <a>Body</a> of the CSV Schema contains the same number of <a title="Column Rule">Column Rules</a>,
					a mismatch is considered a <a>Schema Error</a>.
					The Total Columns Directive is OPTIONAL: when this directive is not used this verification of the number of Column Rules cannot be performed,
					and it will be assumed that you have supplied the correct number of Column Rules.
					</p>
<!--					TotalColumnsDirective       ::=     DirectivePrefix "totalColumns" PositiveNonZeroIntegerLiteral-->
					<table class="ebnf-table">
						<tr>
							<td class="ebnf-num">[10]</td>
							<td class="ebnf-left"><a title="ebnf-total-columns-directive"><dfn>TotalColumnsDirective</dfn></a></td>
							<td>::=</td>
							<td class="ebnf-right"><a>DirectivePrefix</a> "totalColumns" <a>PositiveNonZeroIntegerLiteral</a></td>
						</tr>     
					</table>
				</section>
				<section>
					<h4>No Header Directive</h4>
					<p>
					The <dfn>No Header Directive</dfn> is used to indicate that the CSV file to be validated does not contain a header row: i.e. all rows are data rows.
					The No Header Directive is OPTIONAL: when this directive is not used the parser assumes the default that the first row of the CSV file to be validated contains column names,
					not data, and so the first row is skipped during validation.
					</p>
					<p>
					NB Even when this directive is not specified, the parser is not required to match the <a name="Column Identifier">Column Identifiers</a> present in the CSV file against the Column Identifiers used to 
					specify the <a title="Column Definition">Column Definitions</a> in the <a>Body</a> of the CSV Schema.
					</p>
					<p>
					The No Header Directive is mutually exclusive to the use of the <a>Ignore Column Name Case Directive</a>, when one is used, the other MUST NOT be.
					</p>
					<table class="ebnf-table">
						<tr>
							<td class="ebnf-num">[11]</td>
							<td class="ebnf-left"><a title="ebnf-no-header-directive"><dfn>NoHeaderDirective</dfn></a></td>
							<td>::=</td>
							<td class="ebnf-right"><a>DirectivePrefix</a> "noHeader"</td>
						</tr>     
					</table>
				</section>
				<section>
					<h4>Ignore Column Name Case Directive</h4>
					<p>
					The <dfn>Ignore Column Name Case Directive</dfn> is intended to tell the parser to ignore mismatches in case between the <a name="Column Identifier">Column Identifiers</a> supplied in a CSV file to be validated 
					and those used in giving the <a name="Column Definition">Column Definitions</a>.  However, presently no cross-check is carried out at all.
					</p>
					<p>
					The Ignore Column Name Case Directive is mutually exclusive to the use of the <a>No Header Directive</a>, when one is used, the other MUST NOT be.
					</p>
					<table class="ebnf-table">
						<tr>
							<td class="ebnf-num">[12]</td>
							<td class="ebnf-left"><a title="ebnf-ignore-column-name-case-directive"><dfn>IgnoreColumnNameCaseDirective</dfn></a></td>
							<td>::=</td>
							<td class="ebnf-right"><a>DirectivePrefix</a> "ignoreColumnNameCase"</td>
						</tr>     
					</table>
				</section>
				<section>
					<h4>Example Global Directives</h4>
					<p>
					<pre class="example" title="Global Directives Syntax 1">
	@separator ; @quoted @totalColumns 21 @noHeader
					</pre>
					<pre class="example" title="Global Directives Syntax 2">
	@separator TAB(3)
	@quoted
	@totalColumns 21
	@ignoreColumnNameCase
					</pre>
					</p>			
				</section>
			</section>
		</section>
		<section>
			<h2>Body</h2>
			<p>
			The <dfn>Body</dfn> of a CSV Schema comprises at least one <dfn>Body Part</dfn>, 
			each of which is a combination of OPTIONAL <a title="Comment">Comments</a> with a <a>Column Definition</a> (in either order).
			A Column Definition MUST be included.
			</p>
			<table class="ebnf-table">
				<tr>
					<td class="ebnf-num">[13]</td>
					<td class="ebnf-left"><a title="ebnf-body"><dfn title="body-def">Body</dfn></a></td>
					<td>::=</td>
					<td class="ebnf-right"><a>BodyPart</a>+</td>
				</tr>     
				<tr>
					<td class="ebnf-num">[14]</td>
					<td class="ebnf-left"><a title="ebnf-body-part"><dfn>BodyPart</dfn></a></td>
					<td>::=</td>
					<td class="ebnf-right">((<a title="comment-def">Comment</a>* <a>ColumnDefinition</a>) | (<a>ColumnDefinition</a> <a title="comment-def">Comment</a>*))</td>
				</tr>     
			</table>
			<section>
				<h3>Comments</h3>
				<p>
				There are two types of <dfn>Comment</dfn>: either <a title="Single Line Comment">Single Line</a> or <a title="Multiple Line Comment">Multiple Line</a>.
				</p>
				<p>
				A <dfn>Single Line Comment</dfn> is started with two <code>forward slashes</code>, i.e. the [[UTF-8]] character codes <code>0x2F 0x2F</code>. 
				It is terminated by any [[UTF-8]] character that creates a line-break.
				</p>
				<p>
				A <dfn>Multiple Line Comment</dfn> is started using the combination of a <code>forward slash</code> and an <code>asterisk</code>, 
				i.e. the [[UTF-8]] character codes <code>0x2F 0x2A</code>. 
				It is terminated by the reverse combination, <code>asterisk</code> <code>forward slash</code>, 
				i.e. the [[UTF-8]] character codes <code>0x2A 0x2F</code>. 
				<strong>Any</strong> [[UTF-8]] character may be used between these comment markers, even if it forces a new line.
				Comments do not need to start at the beginning of a line, but must be either before or after a complete <a>Column Definition</a>.
				</p>
				<table class="ebnf-table">
					<tr>
						<td class="ebnf-num">[15]</td>
						<td class="ebnf-left"><a title="ebnf-comment"><dfn title="comment-def">Comment</dfn></a></td>
						<td>::=</td>
						<td class="ebnf-right"><a>SingleLineComment</a> | <a>MultiLineComment</a></td> 
					</tr>     
					<tr>
						<td class="ebnf-num">[16]</td>
						<td class="ebnf-left"><a title="ebnf-single-line-comment"><dfn>SingleLineComment</dfn></a></td>
						<td>::=</td>
						<td class="ebnf-right">"//" <a>NonBreakingChar</a>*</td> 
					</tr>     
					<tr>
						<td class="ebnf-num">[17]</td>
						<td class="ebnf-left"><a title="ebnf-multi-line-comment"><dfn>MultiLineComment</dfn></a></td>
						<td>::=</td>
						<td class="ebnf-right">"/*" <a title="char-def">Char</a>* "*/"</td> 
					</tr>
				</table>
				<section>
					<h4>Example Comments</h4>
					<p>
					<pre class="example" title="Comment Syntax">
	//This Comment is a Single Line Comment it terminates at this line break
	/*This Comment is a Multi Line Comment:
	
	
	it
		
	can
	
	go
	
	on
	
	for as many lines as you like, until you type*/
					</pre>
					</p>		
				</section>
			</section>
			<section>
				<h3>Column Definitions</h3>
				<p>
				<dfn title="Column Definition">Column Definitions</dfn> comprise a <a>Column Identifier</a> or <a>Quoted Column Identifier</a> followed by a <code>colon</code>, 
				i.e. the [[UTF-8]] character code <code>0x3A</code>, followed by a <a>Column Rule</a>.  
				There MUST be a Column Definition for every column in the CSV that will be validated against the Schema.
				</p>
				<table class="ebnf-table">
					<tr>
						<td class="ebnf-num">[18]</td>
						<td class="ebnf-left"><a title="ebnf-column-definition"><dfn>ColumnDefinition</dfn></a></td>
						<td>::=</td>
						<td class="ebnf-right">(<a>ColumnIdentifier</a> | <a>QuotedColumnIdentifier</a>) ":" <a>ColumnRule</a></td> 
					</tr>     
				</table>
				<section>
					<h4>Column Identifiers</h4>
					<p>
					There are two classes of identifier that can be used for columns, the original simple <dfn>Column Identifier</dfn>, and the <dfn>Quoted Column Identifier</dfn>. 
					</p>
					<p>A <a>Column Identifier</a> is either an <a>Integer Literal</a> (most commonly used when the CSV file to be validated has no header row - 
					see <a>No Header Directive</a>) 
					or an <a>Ident</a>.					 
					</p>
					<p>
					The <a>Quoted Column Identifier</a> allows a greater range of characters (<a>Non Double Quote Characters</a> to be used in naming the column, 
					but the identifier must be wrapped in <code>doublequotes</code>, 
					i.e. the [[UTF-8]] character code <code>0x22</code>.
					</p>
					<p>
					Identifiers MUST be unique within a single Schema.
					</p>
					<table class="ebnf-table">
						<tr>
							<td class="ebnf-num">[19]</td>
							<td class="ebnf-left"><a title="ebnf-column-identifier"><dfn>ColumnIdentifier</dfn></a></td>
							<td>::=</td>
							<td class="ebnf-right">(<a>IntegerLiteral</a> | <a title="ident-def">Ident</a>)</td> 
						</tr>     
						<tr>
							<td class="ebnf-num">[20]</td>
							<td class="ebnf-left"><a title="ebnf-quoted-column-identifier"><dfn>QuotedColumnIdentifier</dfn></a></td>
							<td>::=</td>
							<td class="ebnf-right">"\"" <a>NonDoubleQuoteChar</a> "\""</td> 
						</tr>     
					</table>
				</section>
				<section>
					<h4>Column Rules</h4>
					<p>
					A <dfn>Column Rule</dfn> is a combination of any number of <a title="Column Validation Expression">Column Validation Expressions</a>, 
					along with OPTIONAL <a title="Column Directive">Column Directives</a>. 
					You MAY use an empty Column Rule if there is no requirement for an individual column to be validated.
					</p>
					<p>
					As <a title="Column Validation Expression">Column Validation Expressions</a> are the primary means of applying validation, 
					they are described in their own full section of this document.
					The range and variety of expressions available make supplying comprehensive examples here impractical, 
					though some will be used to show the basic structure of a Column Rule.
					</p>
					<p>
					White space is not generally important within a Column Rule, but the whole rule must be on a single line.
					</p>
					<table class="ebnf-table">
						<tr>
							<td class="ebnf-num">[21]</td>
							<td class="ebnf-left"><a title="ebnf-column-rule"><dfn>ColumnRule</dfn></a></td>
							<td>::=</td>
							<td class="ebnf-right"><a>ColumnValidationExpr</a>* <a>ColumnDirectives</a></td> 
						</tr>     
					</table>
					<section>
						<h5>Column Directives</h5>
						<p>
						There are four OPTIONAL <a title="Column Directive">Column Directives</a> that are used 
						to modify aspects of how the <a title="Column Rule">Column Rules</a> are evaluated. 
						Like <a title="Global Directive">Global Directives</a>, Column Directives are indicated by the <a>Directive Prefix</a>, 
						defined as the character <code>@</code> i.e. the [[UTF-8]] character code <code>0x40</code>.
						</p>
						<p>
						The Column Directives are the <a>Optional Directive</a>, the <a>Match Is False Directive</a>, the <a>Ignore Case Directive</a>, 
						and the <a>Warning Directive</a>.  The first three may be specified in any order (though there is no straightforward way to express this in <a>EBNF</a> 
						without listing every possible order).  The Warning Directive must always be specified last.
						</p>
						<section>
							<h6>Optional Directive</h6>
							<p>
							The <dfn>Optional Directive</dfn> is used when completion of the data field in the original CSV file to be validated is OPTIONAL. 
							When this directive is used the data in the column is considered valid if the <a>Column Rule</a> evaluates to true, of if the column is empty.
							</p>
							<table class="ebnf-table">
								<tr>
									<td class="ebnf-num">[22]</td>
									<td class="ebnf-left"><a title="ebnf-optional-directive"><dfn>OptionalDirective</dfn></a></td>
									<td>::=</td>
									<td class="ebnf-right"><a>DirectivePrefix</a> "optional"</td> 
								</tr>     
							</table>
						</section>
						<section>
							<h6>Match Is False Directive</h6>
							<p>
							The <dfn>Match Is False Directive</dfn> is used to flip the result of a test from negative to positive (or vice-versa).
							It may be very simple to write a condition which matches the data considered to be invalid, while the equivalent for valid data would be very convoluted.
							</p>
							<table class="ebnf-table">
								<tr>
									<td class="ebnf-num">[23]</td>
									<td class="ebnf-left"><a title="ebnf-match-is-false-directive"><dfn>MatchIsFalseDirective</dfn></a></td>
									<td>::=</td>
									<td class="ebnf-right"><a>DirectivePrefix</a> "matchIsFalse"</td> 
								</tr>     
							</table>
						</section>
						<section>
							<h6>Ignore Case Directive</h6>
							<p>
							The <dfn>Ignore Case Directive</dfn> is used when the case of a column is not important. 
							Two strings which differ only in the case used for characters within the string would be considered a match.
							</p>
							<table class="ebnf-table">
								<tr>
									<td class="ebnf-num">[24]</td>
									<td class="ebnf-left"><a title="ebnf-ignore-case-directive"><dfn>IgnoreCaseDirective</dfn></a></td>
									<td>::=</td>
									<td class="ebnf-right"><a>DirectivePrefix</a> "ignoreCase"</td> 
								</tr>     
							</table>
						</section>
						<section>
							<h6>Warning Directive</h6>
							<p>
							The <dfn>Warning Directive</dfn> is used to convert a <a>Validation Error</a> into a <a>Validation Warning</a>.  
							This is useful if you wish to be alerted to a data condition which is unusual, but not necessarily invalid.
							For instance, at The National Archives we have come across archival material where the clerk who originally completed a form 
							wrote down an "impossible" date such as 30 February or 31 April. We have to do our best to accept the data as originally supplied 
							(we have no idea if it is the day or month of the date which is actually incorrect), but we also wish to ensure that additional 
							Quality Assurance checking is performed to ensure this is not a transcription error. Warnings are listed in the validation report, 
							but the data file is still considered valid if only warnings are present.
							</p>
							<table class="ebnf-table">
								<tr>
									<td class="ebnf-num">[25]</td>
									<td class="ebnf-left"><a title="ebnf-warning-directive"><dfn>WarningDirective</dfn></a></td>
									<td>::=</td>
									<td class="ebnf-right"><a>DirectivePrefix</a> "warning"</td> 
								</tr>     
							</table>
						</section>
					</section>
				</section>
				<section>
					<h4>Column Definitions examples</h4>
					<p>
					<pre class="example" title="Column Definition Syntax">
	a_column_title:       is("somedata") or is("otherdata")        @optional @matchIsFalse @ignoreCase @warning
	another_column_title: isNot("somedata") and isNot("otherdata")                         @ignoreCase
					</pre>
					The two Column Definitions are both validating the data in their respective columns against the explicit strings <code>somedata</code> and <code>otherdata</code>.
					Ignoring the column directives for the moment, the column rule defined for <code>a_column_title</code> would return true if the CSV data for that column 
					contained either the precise string <code>somedata</code> or <code>otherdata</code>.  However, the <a>Optional Directive</a> means a completely empty column 
					would also be acceptable. Also, since the <a>Ignore Case Directive</a> is also applied, the strings <code>SomeData</code> or <code>OTHERDATA</code> (for example) 
					would also be acceptable.  But, since the <a>Match Is False Directive</a> is in effect, the validation is inverted, it would actually be any string <em>other</em> 
					than the two specified which would be regarded as acceptable data.  Since the <a>Warning Directive</a> is also used, a validation failure would not be considered 
					an error though.
					</p>
					<p>
					The second Column Definition (with the effect of the <a>Match Is False Directive</a> on the first taken into account) is actually logically equivalent to the first 
					(see <a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws">De Morgan's Laws</a>).  However, since the <a>Optional Directive</a> has not been used, an empty column 
					would not be valid data, and since the <a>Warning Directive</a> has also not been included, such invalid data would be considered a <a>Validation Error</a>.					
					</p>
				</section>
			</section>
		</section>
	</section>
    <section>
		<h1>Column Validation Expressions</h1>
		<p>
		The key building blocks for <a title="Column Rule">Column Rules</a> are <dfn title="Column Validation Expression">Column Validation Expressions</dfn>.  
		These are divided into two main classes, <a title="Non Conditional Expression">Non Conditional Expressions</a> and <a title="Conditional Expression">Conditional Expressions</a>.
		Non Conditional Expressions boil down to checks resulting in a pass or fail (a number of expressions may be combined to produce an overall validation check), Conditional Expressions allow for more subtle checks, 
		if for example you are validating a <code>title</code> column which allows the values <code>Mr</code>, <code>Mrs</code>, <code>Ms</code>, <code>Miss</code> and <code>Dr</code>, 
		You could construct a Conditional Expression which also checks the <code>sex</code> column and if that contains <code>female</code>, 
		then <code>Mr</code> would be regarded as invalid (strictly speaking that would also require the use of an <a>Explicit Context Expression</a> to refer to the other column, 
		but that is a subexpression of the Non Conditional Expression class).
		</p>
		<table class="ebnf-table">
			<tr>
				<td class="ebnf-num">[26]</td>
				<td class="ebnf-left"><a title="ebnf-column-validation-expr"><dfn>ColumnValidationExpression</dfn></a></td>
				<td>::=</td>
				<td class="ebnf-right"><a>NonConditionalExpr</a> | <a>ConditionalExpr</a></td> 
			</tr>     
		</table>
		<section>
			<h2>Non Conditional Expressions</h2>
			<p>
			<dfn title="Non Conditional Expression">Non Conditional Expressions</dfn> are divided into four classes of subexpressions: 
			<a title="Single Expression">Single Expressions</a>, <a title="External Single Expression">External Single Expressions</a>, 
			<a title="Combinatorial Expression">Combinatorial Expressions</a>, and <a title="Parenthesized Expression">Parenthesized Expressions</a>. 
			The first two are individual validation checks (differing in that the second allows access to some resource outside the CSV file being validated), 
			While the last two provide ways of combining checks into more complex compound forms.
			</p>
			<table class="ebnf-table">
				<tr>
					<td class="ebnf-num">[27]</td>
					<td class="ebnf-left"><a title="ebnf-column-non-conditional-expr"><dfn>NonConditionalExpr</dfn></a></td>
					<td>::=</td>
					<td class="ebnf-right"><a>SingleExpr</a> | <a>ExternalSingleExpr</a> | <a>CombinatorialExpr</a> | <a>ParenthesizedExpr</a></td> 
				</tr>     
			</table>
			<section>
				<h3>Single Expressions</h3>
				<p>
				<dfn title="Single Expression">Single Expressions</dfn> are the basic building blocks of <a>Column Rules</a>.  There are currently 22 available for use 
				(and some have their own subexpressions used as parameters), although the first is really used as an OPTIONAL modifier to the rest. 
				In many cases values can be provided to the test either as an explicit string (or number where appropriate), or by reference to the value held by another column.
				</p>
				<table class="ebnf-table">
					<tr>
						<td class="ebnf-num">[28]</td>
						<td class="ebnf-left"><a title="ebnf-single-expr"><dfn>SingleExpr</dfn></a></td>
						<td>::=</td>
						<td class="ebnf-right">(<a>ExplicitContextExpr</a>)? <a>IsExpr</a> | <a>NotExpr</a> | <a>InExpr</a> | <a>StartsWithExpr</a> | <a>EndsWithExpr</A> | 
						<a>RegExpExpr</a> | <a>RangeExpr</a> | <a>LengthExpr</a> | <a>EmptyExpr</a> | <a>NotEmptyExpr</a> | <a>UniqueExpr</a> | <a>UriExpr</a> | <a>XsdDateTimeExpr</a> | 
						<a>XsdDateExpr</a> | <a>UkDateExpr</a> | <a>XsdTimeExpr</a> | <a>Uuid4Expr</a> | <a>PositiveIntegerExpr</a></td> 
					</tr>     
				</table>	
				<section>
					<h4>Explicit Context Expressions</h4>
					<p>
					The <dfn>Explicit Context Expression</dfn> is used to indicate that the expression following should be tested against the value in another specified column, 
					rather than the current column (which is the default context).
					</p>
					<table class="ebnf-table">
						<tr>
							<td class="ebnf-num">[29]</td>
							<td class="ebnf-left"><a title="ebnf-explicit-context-expr"><dfn>ExplicitContextExpr</dfn></a></td>
							<td>::=</td>
							<td class="ebnf-right"><a>ColumnRef</a> "/"</td> 
						</tr>     
					</table>	
				</section>
				<section>
					<h4>Is Expressions</h4>
					<p>
					An <dfn>Is Expression</dfn> checks that the value of the column is identical to the supplied string or the value in the referenced column.
					</p>
					<table class="ebnf-table">
						<tr>
							<td class="ebnf-num">[30]</td>
							<td class="ebnf-left"><a title="ebnf-is-expr"><dfn>IsExpr</dfn></a></td>
							<td>::=</td>
							<td class="ebnf-right">"is(" <a>StringProvider</a> ")"</td> 
						</tr>     
					</table>	
				</section>
				<section>
					<h4>Not Expressions</h4>
					<p>
					A <dfn>Not Expression</dfn> checks that the value of the column is not equal to the supplied string or the value in the referenced column.
					</p>
					<table class="ebnf-table">
						<tr>
							<td class="ebnf-num">[31]</td>
							<td class="ebnf-left"><a title="ebnf-not-expr"><dfn>NotExpr</dfn></a></td>
							<td>::=</td>
							<td class="ebnf-right">"not(" <a>StringProvider</a> ")"</td> 
						</tr>     
					</table>	
				</section>
				<section>
					<h4>In Expressions</h4>
					<p>
					An <dfn>In Expression</dfn> checks that the value of the column contains the supplied string or the value in the referenced column 
					(i.e. the column value is a super string of the supplied value).
					</p>
					<table class="ebnf-table">
						<tr>
							<td class="ebnf-num">[32]</td>
							<td class="ebnf-left"><a title="ebnf-in-expr"><dfn>InExpr</dfn></a></td>
							<td>::=</td>
							<td class="ebnf-right">"in(" <a>StringProvider</a> ")"</td> 
						</tr>     
					</table>	
				</section>
				<section>
					<h4>Starts With Expressions</h4>
					<p>
					A <dfn>Starts With Expression</dfn> checks that the value of the column begins with the supplied string or the value in the referenced column.
					</p>
					<table class="ebnf-table">
						<tr>
							<td class="ebnf-num">[33]</td>
							<td class="ebnf-left"><a title="ebnf-starts-with-expr"><dfn>StartsWithExpr</dfn></a></td>
							<td>::=</td>
							<td class="ebnf-right">"starts(" <a>StringProvider</a> ")"</td> 
						</tr>     
					</table>	
				</section>
				<section>
					<h4>Ends With Expressions</h4>
					<p>
					An <dfn>Ends With Expression</dfn> checks that the value of the column finished with the supplied string or the value in the referenced column.
					</p>
					<table class="ebnf-table">
						<tr>
							<td class="ebnf-num">[34]</td>
							<td class="ebnf-left"><a title="ebnf-ends-with-expr"><dfn>EndsWithExpr</dfn></a></td>
							<td>::=</td>
							<td class="ebnf-right">"ends(" <a>StringProvider</a> ")"</td> 
						</tr>     
					</table>	
				</section>
				<section>
					<h4>Regular Expression Expressions</h4>
					<p>
					A <dfn>Regular Expression Expression</dfn> checks the value of the column against the supplied Regular Expression.
					</p>
					<table class="ebnf-table">
						<tr>
							<td class="ebnf-num">[35]</td>
							<td class="ebnf-left"><a title="ebnf-reg-exp-expr"><dfn>RegExpExpr</dfn></a></td>
							<td>::=</td>
							<td class="ebnf-right">"regex(" <a>StringLiteral</a> ")"</td> 
						</tr>     
					</table>	
				</section>
				<section>
					<h4>Range Expressions</h4>
					<p>
					A <dfn>Range Expression</dfn> checks that the value of the column is a number lying between, or equal to, the supplied upper and lower bounds.
					</p>
					<table class="ebnf-table">
						<tr>
							<td class="ebnf-num">[36]</td>
							<td class="ebnf-left"><a title="ebnf-range-expr"><dfn>RangeExpr</dfn></a></td>
							<td>::=</td>
							<td class="ebnf-right">"range(" <a>NumericLiteral</a> "," NumericLiteral ")"</td> 
						</tr>     
					</table>	
				</section>
				<section>
					<h4>Length Expressions</h4>
					<p>
					A <dfn>Length Expression</dfn> checks that the number of characters in the column meets the supplied definition.  You can specify that the column is:
					<ol>
						<li>Precisely <em>n</em> characters long;</li>
						<li>At least <em>n</em> characters long;</li>
						<li>At most <em>n</em> characters long;</li>
						<li>Between <em>m</em> and <em>n</em> characters long (inclusive).</li>
					</ol>
					</p>
					<table class="ebnf-table">
						<tr>
							<td class="ebnf-num">[37]</td>
							<td class="ebnf-left"><a title="ebnf-length-expr"><dfn>LengthExpr</dfn></a></td>
							<td>::=</td>
							<td class="ebnf-right">"length(" (<a>PositiveIntegerOrAny</a> ",")? PositiveIntegerOrAny ")"</td> 
						</tr>     
					</table>	
				</section>
				<section>
					<h4>Empty Expressions</h4>
					<p>
					An <dfn>Empty Expression</dfn> checks that the column has no content.
					</p>
					<table class="ebnf-table">
						<tr>
							<td class="ebnf-num">[38]</td>
							<td class="ebnf-left"><a title="ebnf-empty-expr"><dfn>EmptyExpr</dfn></a></td>
							<td>::=</td>
							<td class="ebnf-right">"empty"</td> 
						</tr>     
					</table>	
				</section>
				<section>
					<h4>Not Empty Expression</h4>
					<p>
					A <dfn>Not Empty Expression</dfn> checks that the column has some content, though precisely what does not matter.
					</p>
					<table class="ebnf-table">
						<tr>
							<td class="ebnf-num">[39]</td>
							<td class="ebnf-left"><a title="ebnf-not-empty-expr"><dfn>NotEmptyExpr</dfn></a></td>
							<td>::=</td>
							<td class="ebnf-right">"notEmpty"</td> 
						</tr>     
					</table>	
				</section>
				<section>
					<h4>Unique Expressions</h4>
					<p>
					A <dfn>Unique Expression</dfn> checks that the column value is unique within the CSV file being validated 
					(within the current column, the value may occur elsewhere in the file in another column, as in a primary-foreign key relationship in a database).  
					You can also specify a comma separated list of <a title="Column Identifier">Column Identifiers</a> in which case the combination of values of those columns 
					(for the current row) must be unique within the whole CSV file.
					</p>
					<table class="ebnf-table">
						<tr>
							<td class="ebnf-num">[40]</td>
							<td class="ebnf-left"><a title="ebnf-unique-expr"><dfn>UniqueExpr</dfn></a></td>
							<td>::=</td>
							<td class="ebnf-right">"unique" ("(" <a>ColumnRef</a> ("," ColumnRef)* ")")?</td> 
						</tr>     
					</table>	
				</section>
				<section>
					<h4>URI Expressions</h4>
				<p>
				A <dfn>URI Expression</dfn> checks that the value in the column is a valid URI as defined in [[!RFC3986]].
				</p>
					<table class="ebnf-table">
						<tr>
							<td class="ebnf-num">[41]</td>
							<td class="ebnf-left"><a title="ebnf-unique-expr"><dfn>UriExpr</dfn></a></td>
							<td>::=</td>
							<td class="ebnf-right">"uri"</td> 
						</tr>     
					</table>	
				</section>
				<section>
					<h4>XSD Date Time Expressions</h4>
					<p>
					An <dfn>XSD Date Time Expression</dfn> checks that the data in the column is expressed as a valid XML Schema dateTime data type (see [[!XMLSCHEMA-2]] and [[!ISO8601]]). 
					You can also provide an OPTIONAL <dfn>From XSD Date Time Expression</dfn> and <dfn>To XSD Date Time Expression</dfn> 
					(inclusive, and in the same XML Schema dateTime format) to ensure that the value in the column falls within an expected date-time range.
					</p>
					<table class="ebnf-table">
						<tr>
							<td class="ebnf-num">[42]</td>
							<td class="ebnf-left"><a title="ebnf-xsd-date-time-expr"><dfn>XsdDateTimeExpr</dfn></a></td>
							<td>::=</td>
							<td class="ebnf-right">"xDateTime" ("(" <a>fromXsdDateTimeExpr</a> "," <a>toXsdDateTimeExpr</a> ")")?</td> 
						</tr>     
					</table>	
				</section>
				<section>
					<h4>XSD Date Expressions</h4>
					<p>
					An <dfn>XSD Date Expression</dfn> checks that the data in the column is expressed as a valid XML Schema date data type (see [[!XMLSCHEMA-2]] and [[!ISO8601]]). 
					You can also provide OPTIONAL from and to dates (inclusive, and in the same XML Schema date format) 
					to ensure that the value in the column falls within an expected date range.
					</p>
					<table class="ebnf-table">
						<tr>
							<td class="ebnf-num">[43]</td>
							<td class="ebnf-left"><a title="ebnf-xsd-date-expr"><dfn>XsdDateExpr</dfn></a></td>
							<td>::=</td>
							<td class="ebnf-right">"xDate" ("(" <a>fromXsdDateExpr</a> "," <a>toXsdDateExpr</a> ")")?</td> 
						</tr>     
					</table>	
				</section>
				<section>
					<h4>XSD Time Expressions</h4>
					<p>
					An <dfn>XSD Time Expression</dfn> checks that the data in the column is expressed as a valid XML Schema time data type (see [[!XMLSCHEMA-2]] and [[!ISO8601]]). 
					You can also provide OPTIONAL from and to times (inclusive, and in the same XML Schema time format) 
					to ensure that the value in the column falls within an expected date range.
					</p>
					<table class="ebnf-table">
						<tr>
							<td class="ebnf-num">[44]</td>
							<td class="ebnf-left"><a title="ebnf-xsd-time-expr"><dfn>XsdTimeExpr</dfn></a></td>
							<td>::=</td>
							<td class="ebnf-right">"xTime" ("(" <a>fromXsdTimeExpr</a> "," <a>toXsdTimeExpr</a> ")")?</td> 
						</tr>     
					</table>	
				</section>
				<section>
					<h4>UK Date Expressions</h4>
					<p>
					A <dfn>UK Date Expression</dfn> checks that the data in the column is expressed as a valid UK-style date, dd/mm/yyyy. 
					You can also provide OPTIONAL from and to date-times (inclusive, and in the same format) 
					to ensure that the value in the column falls within an expected date-time range.
					</p>
					<table class="ebnf-table">
						<tr>
							<td class="ebnf-num">[45]</td>
							<td class="ebnf-left"><a title="ebnf-uk-date-expr"><dfn>UkDateExpr</dfn></a></td>
							<td>::=</td>
							<td class="ebnf-right">"ukDate" ("(" <a>fromUkDateExpr</a> "," <a>toUkDateExpr</a> ")")?</td> 
						</tr>     
					</table>	
				</section>
				<section>
					<h4>Date Expression</h4>
					<p>
					A <dfn>Date Expression</dfn> allows a full date to be constructed from several columns, or strings. The expression takes five arguments:
					you MUST supply three strings or <a title="Column Reference">Column References</a> representing Year, Month and Day 
					(although supplied as strings, these values must in fact be integers); 
					and there are two OPTIONAL parameters to ensure the date falls in a range specified by <a>From XSD Date Time Expression</a> and <a>To XSD Date Time Expression</a>.
					</p>
					<table class="ebnf-table">
						<tr>
							<td class="ebnf-num">[46]</td>
							<td class="ebnf-left"><a title="ebnf-date-expr"><dfn>DateExpr</dfn></a></td>
							<td>::=</td>
							<td class="ebnf-right">"date(" <a>StringProvider</a> "," StringProvider "," StringProvider ("," <a>fromXsdDateExpr</a> "," <a>toXsdDateExpr</a>)? ")"</td> 
						</tr>     
					</table>
				</section>
				<section>
					<h4>Partial UK Date Expression</h4>
					<p>
					A <dfn>Partial UK Date Expression</dfn> is essentially the same as a <a>UK Date Expression</a>, 
					but allows for difficulties in transcribing from original archival material by accepting a <code>question mark</code>, 
					i.e. the [[UTF-8]] character code <code>0x3F</code> in place of illegible digits in any position, or an <code>asterisk</code>, 
					i.e. the [[UTF-8]] character code <code>0x2A</code> in place of a missing value.  As dates may not be complete, 
					it is impossible to determine reliably if a date falls within a given range, so there is no option to supply one.
					</p>
					<table class="ebnf-table">
						<tr>
							<td class="ebnf-num">[47]</td>
							<td class="ebnf-left"><a title="ebnf-partial-uk-date-expr"><dfn>PartialUkDateExpr</dfn></a></td>
							<td>::=</td>
							<td class="ebnf-right">"partUkDate"</td> 
						</tr>     
					</table>
				</section>
				<section>
					<h4>Partial Date Expression</h4>
					<p>
					A <dfn>Partial Date Expression</dfn> combines elements of <a>Partial UK Date Expression</a> with those of <a>Date Expression</a>, 
					with the date being made up of columns or strings as in Date Expression, but also allowing the characters representing uncertainty as in Partial UK Date Expression.
					However, the constituent parts of the date MUST be supplied as year, month, day.
					</p>
					<table class="ebnf-table">
						<tr>
							<td class="ebnf-num">[48]</td>
							<td class="ebnf-left"><a title="ebnf-partial-date-expr"><dfn>PartialDateExpr</dfn></a></td>
							<td>::=</td>
							<td class="ebnf-right">"partDate(" <a>StringProvider</a> "," StringProvider "," StringProvider ")"</td> 
						</tr>     
					</table>
				</section>
				<section>
					<h4>UUID4 Expression</h4>
					<p>
					A <dfn>UUID4 Expression</dfn> checks that the data in the column is in the form of a Version 4 UUID 
					(<strong>U</strong>niversally <strong>U</strong>nique <strong>Id</strong>entifier), see [[!RFC4122]].
					</p>
					<table class="ebnf-table">
						<tr>
							<td class="ebnf-num">[49]</td>
							<td class="ebnf-left"><a title="ebnf-uuid4-expr"><dfn>Uuid4Expr</dfn></a></td>
							<td>::=</td>
							<td class="ebnf-right">"uuid4"</td> 
						</tr>     
					</table>
				</section>
				<section>
					<h4>Positive Integer Expression</h4>
					<p>
					A <dfn>Positive Integer Expression</dfn> checks that the column contains an integer value, greater than or equal to zero.
					</p>
					<table class="ebnf-table">
						<tr>
							<td class="ebnf-num">[49]</td>
							<td class="ebnf-left"><a title="ebnf-positive-integer-expr"><dfn>PositiveIntegerExpr</dfn></a></td>
							<td>::=</td>
							<td class="ebnf-right">"positiveInteger"</td> 
						</tr>     
					</table>
				</section>
			</section>
		</section>
	</section>
	
	
      TODO a note on file uri handling on different platforms etc!
      TODO a note on mime-type and filenaming
      
    <section class="appendix">
			<h2>CSV Schema Grammar</h2>
			<section>
			<h3>EBNF</h3>
			<p>
			Conventions used in this appendix: 
			links on the <em>left</em> of a definition go to more detailed discussion of the term in the body of this document;
			links on the <em>right</em> of a definition go to a further definition within this appendix.
			</p>
			<table class="ebnf-table">
				<tr>
					<td class="ebnf-num">[1]</td>
					<td class="ebnf-left"><a><dfn title="ebnf-schema">Schema</dfn></a></td>
					<td>::=</td>
					<td class="ebnf-right"><a title="ebnf-prolog">Prolog</a> <a title="ebnf-body">Body</a></td>
				</tr>
				<tr>
					<td class="ebnf-num">[2]</td>
					<td class="ebnf-left"><a title="prolog-def"><dfn title="ebnf-prolog">Prolog</dfn></a></td>
					<td>::=</td>
					<td class="ebnf-right"><a title="ebnf-version-decl">VersionDecl</a> <a title="ebnf-global-directives">GlobalDirectives</a></td>
				</tr>
				<tr>
					<td class="ebnf-num">[3]</td>
					<td class="ebnf-left"><a><dfn title="ebnf-version-decl">VersionDecl</dfn></a></td>
					<td>::=</td>
					<td class="ebnf-right">"version 1.0"</td>
				</tr>
				<tr>
					<td class="ebnf-num">[4]</td>
					<td class="ebnf-left"><a><dfn title="ebnf-global-directives">GlobalDirectives</dfn></a></td>
					<td>::=</td>
					<td class="ebnf-right"><a title="ebnf-separator-directive">SeparatorDirective</a>? <a title="ebnf-quoted-directive">QuotedDirective</a>? <a title="ebnf-total-columns-directive">TotalColumnsDirective</a>? (<a title="ebnf-no-header-directive">NoHeaderDirective</a> | <a title="ebnf-ignore-column-name-case-directive">IgnoreColumnNameCaseDirective</a>)?</td>
				</tr>
				<tr>
					<td class="ebnf-num">[5]</td>
					<td class="ebnf-left"><a><dfn title="ebnf-directive-prefix">DirectivePrefix</dfn></a></td>
					<td>::=</td>
					<td class="ebnf-right">"@"</td>
				</tr>
				<tr>
					<td class="ebnf-num">[6]</td>
					<td class="ebnf-left"><a><dfn title="ebnf-separator-directive">SeparatorDirective</dfn></a></td>
					<td>::=</td>
					<td class="ebnf-right"><a title="ebnf-directive-prefix">DirectivePrefix</a> "separator" (<a title="ebnf-tab-expr">TABExpr</a> | <a title="ebnf-separator-char">SeparatorChar</a>)</td>
				</tr>
				<tr>
					<td class="ebnf-num">[7]</td>
					<td class="ebnf-left"><a><dfn title="ebnf-tab-expr">TABExpr</dfn></a></td>
					<td>::=</td>
					<td class="ebnf-right">"TAB" ("(" <a title="ebnf-integer-literal">IntegerLiteral</a> ")")?</td>
				</tr>
				<tr>
					<td class="ebnf-num">[8]</td>
					<td class="ebnf-left"><a><dfn title="ebnf-separator-char">SeparatorChar</dfn></a></td>
					<td>::=</td>
					<td class="ebnf-right"><a title="ebnf-character-literal">CharacterLiteral</a></td>
				<tr>
					<td class="ebnf-num">[9]</td>
					<td class="ebnf-left"><a><dfn title="ebnf-quoted-directive">QuotedDirective</dfn></a></td>
					<td>::=</td>
				  <td class="ebnf-right"><a title="ebnf-directive-prefix">DirectivePrefix</a> "quoted"</td>
				</tr>
				<tr>
					<td class="ebnf-num">[10]</td>
					<td class="ebnf-left"><a><dfn title="ebnf-total-columns-directive">TotalColumnsDirective</dfn></a></td>
					<td>::=</td>
					<td class="ebnf-right"><a title="ebnf-directive-prefix">DirectivePrefix</a> "totalColumns" <a title="ebnf-positive-non-zero-integer-literal">PositiveNonZeroIntegerLiteral</a></td>
				</tr>     
				<tr>
					<td class="ebnf-num">[11]</td>
					<td class="ebnf-left"><a><dfn title="ebnf-no-header-directive">NoHeaderDirective</dfn></a></td>
					<td>::=</td>
					<td class="ebnf-right"><a title="ebnf-directive-prefix">DirectivePrefix</a> "noHeader"</td>
				</tr>     
				<tr>
					<td class="ebnf-num">[12]</td>
					<td class="ebnf-left"><a><dfn title="ebnf-ignore-column-name-case-directive">IgnoreColumnNameCaseDirective</dfn></a></td>
					<td>::=</td>
					<td class="ebnf-right"><a title="ebnf-directive-prefix">DirectivePrefix</a> "ignoreColumnNameCase"</td>
				</tr>     
				<tr>
					<td class="ebnf-num">[13]</td>
					<td class="ebnf-left"><a title="body-def"><dfn title="ebnf-body">Body</dfn></a></td>
					<td>::=</td>
					<td class="ebnf-right"><a title="ebnf-body-part">BodyPart</a>+</td>
				</tr>     
				<tr>
					<td class="ebnf-num">[14]</td>
					<td class="ebnf-left"><a><dfn title="ebnf-body-part">BodyPart</dfn></a></td>
					<td>::=</td>
					<td class="ebnf-right">((<a title="ebnf-comment">Comment</a>* <a title="ebnf-column-definition">ColumnDefinition</a>) | (<a title="ebnf-column-definition">ColumnDefinition</a> <a title="ebnf-comment">Comment</a>*))</td>
				</tr>     
				<tr>
					<td class="ebnf-num">[15]</td>
					<td class="ebnf-left"><a title="comment-def"><dfn title="ebnf-comment">Comment</dfn></a></td>
					<td>::=</td>
					<td class="ebnf-right"><a title="ebnf-single-line-comment">SingleLineComment</a> | <a title="ebnf-multi-line-comment">MultiLineComment</a></td>
				</tr>     
				<tr>
					<td class="ebnf-num">[16]</td>
					<td class="ebnf-left"><a><dfn title="ebnf-single-line-comment">SingleLineComment</dfn></a></td>
					<td>::=</td>
					<td class="ebnf-right">"//" <a title="ebnf-non-breaking-char">NonBreakingChar</a>*</td>
				</tr>     
				<tr>
					<td class="ebnf-num">[17]</td>
					<td class="ebnf-left"><a><dfn title="ebnf-multi-line-comment">MultiLineComment</dfn></a></td>
					<td>::=</td>
					<td class="ebnf-right">"/*" <a title="ebnf-char">Char</a>* "*/"</td>
				</tr>     
				<tr>
					<td class="ebnf-num">[18]</td>
					<td class="ebnf-left"><a><dfn title="ebnf-column-definition">ColumnDefinition</dfn></a></td>
					<td>::=</td>
					<td class="ebnf-right">(<a title="ebnf-column-identifier">ColumnIdentifier</a> | <a title="ebnf-quoted-column-identifier">QuotedColumnIdentifier</a>) ":" <a title="ebnf-column-rule">ColumnRule</a></td>
				</tr>     
				<tr>
					<td class="ebnf-num">[19]</td>
					<td class="ebnf-left"><a><dfn title="ebnf-column-identifier">ColumnIdentifier</dfn></a></td>
					<td>::=</td>
					<td class="ebnf-right">(<a title="ebnf-integer-literal">IntegerLiteral</a> | <a title="ebnf-ident">Ident</a>)</td>
				</tr>     
				<tr>
					<td class="ebnf-num">[20]</td>
					<td class="ebnf-left"><a><dfn title="ebnf-quoted-column-identifier">QuotedColumnIdentifier</dfn></a></td>
					<td>::=</td>
					<td class="ebnf-right">"\"" <a title="ebnf-integer-literal">NonDoubleQuoteChar</a> "\""</td>
				</tr>     
				<tr>
					<td class="ebnf-num">[21]</td>
					<td class="ebnf-left"><a><dfn title="ebnf-column-rule">ColumnRule</dfn></a></td>
					<td>::=</td>
					<td class="ebnf-right"><a title="ebnf-column-validation-expr">ColumnValidationExpr</a>* <a title="ebnf-column-directives">ColumnDirectives</a></td>
				</tr>     
				<tr>
					<td class="ebnf-num">[22]</td>
					<td class="ebnf-left"><a><dfn title="ebnf-optional-directive">OptionalDirective</dfn></a></td>
					<td>::=</td>
					<td class="ebnf-right"><a title="ebnf-directive-prefix">DirectivePrefix</a> "optional"</td>
				</tr>     
				<tr>
					<td class="ebnf-num">[23]</td>
					<td class="ebnf-left"><a><dfn title="ebnf-match-is-false-directive">MatchIsFalseDirective</dfn></a></td>
					<td>::=</td>
					<td class="ebnf-right"><a title="ebnf-directive-prefix">DirectivePrefix</a> "matchIsFalse"</td>
				</tr>     
				<tr>
					<td class="ebnf-num">[24]</td>
					<td class="ebnf-left"><a><dfn title="ebnf-ignore-case-directive">IgnoreCaseDirective</dfn></a></td>
					<td>::=</td>
					<td class="ebnf-right"><a title="ebnf-directive-prefix">DirectivePrefix</a> "ignoreCase"</td>
				</tr>     
				<tr>
					<td class="ebnf-num">[25]</td>
					<td class="ebnf-left"><a><dfn title="ebnf-warning-directive">WarningDirective</dfn></a></td>
					<td>::=</td>
					<td class="ebnf-right"><a title="ebnf-directive-prefix">DirectivePrefix</a> "warningDirective"</td>
				</tr>     
				<tr>
					<td class="ebnf-num">[26]</td>
					<td class="ebnf-left"><a><dfn title="ebnf-column-validation-expr">ColumnValidationExpression</dfn></a></td>
					<td>::=</td>
					<td class="ebnf-right"><a title="ebnf-non-conditional-expr">NonConditionalExpr</a> | <a title="ebnf-conditional-expr">ConditionalExpr</a></td>
				</tr>     
				<tr>
					<td class="ebnf-num">[27]</td>
					<td class="ebnf-left"><a><dfn title="ebnf-non-conditional-expr">NonConditionalExpr</dfn></a></td>
					<td>::=</td>
					<td class="ebnf-right"><a title="ebnf-non-single-expr">SingleExpr</a> | <a title="ebnf-external-single-expr">ExternalSingleExpr</a> | <a title="ebnf-combinatorial-expr">CombinatorialExpr</a> | <a title="ebnf-parenthesized-expr">ParenthesizedExpr</a></td>
				</tr>     
			</table>
		</section>
    </section>  
      
      
    <section class='appendix'>
      <h2>Acknowledgements</h2>
      <p>
        Many thanks to:
        <ul>
            <li>Robin Berjon for making the production of this specification much simpler with his cool <a href="https://github.com/darobin/respec">ReSpec</a> tool.</li>
        </ul>
      </p>
    </section>
  </body>
</html>
